namespace Ode.Domain.Engine
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Brokers;
    using Dispatchers;
    using Model;
    using Repositories;
    using Transactions;
         
    /// <summary>
    /// Domain engine for processing commands against aggregates and optionly related event handlers.
    /// The behaviour of the domain engine varies depending on its configuration.  By default the domain 
    /// engine processes a single command against a single aggreaget root and returns any events generated 
    /// by that aggregate.  Providing a broker can change this behaviour so that potentialy all related 
    /// event handlers and follow-up commands are recursively processed untill the entire domain has
    /// been updaged to reflect the flow on effects of the command.
    /// </summary>
    public class DomainEngine : IDomainEngine
    {
        private readonly IBoundedContextModel boundedContextModel;
        private readonly IRuntimeModel runtimeModel;
        private readonly ICommandHandler commandHandler;
        private IEventDispatcher eventDispatcher;
        private IEventBroker eventBroker;
        private IEventQueueWriter eventQueue;
        private DomainOptions domainOptions = DomainOptions.Defaults;

        /// <summary>
        /// Creates a new instance of a domain engine for processing commands and optionly event handlers from a single bounded context.  By default the engine will process a command
        /// handler & aggregate root for a command and return any events generated by the aggregate.  
        /// </summary>
        /// <param name="boundedContextModel">Describes the static model of the domain.  Include the command handlers and any event handlers to be executed in process.</param>
        /// <param name="eventStore">The event store used for event persistence by both command and event handers.</param>
        /// <param name="options">Options relating to the domain engine exection.</param>
        public DomainEngine(IBoundedContextModel boundedContextModel, IEventStore eventStore, DomainOptions options)
        {
            this.boundedContextModel = boundedContextModel;
            this.runtimeModel = new RuntimeModel(boundedContextModel, eventStore);
            this.commandHandler = new CommandHandler(boundedContextModel, runtimeModel);
            this.domainOptions = options;
        }

        /// <summary>
        /// Informs the domain engine to use the default event broker to internally negotiate the events generated by aggregates with all configured event handlers recursively.
        /// Call this method to have the domain engine fully and recursivly process commands and events untill all configured handlers are satisfied.
        /// </summary>
        /// <returns>Domain inteface for processing commands.</returns>
        public DomainEngine WithEventBroker()
        {
            this.eventBroker = new DomainBroker(this.boundedContextModel, new EventHandler(this.boundedContextModel, this.runtimeModel), this.commandHandler);
            return this;
        }

        /// <summary>
        /// Informs the domain engine to use the provided event broker to negotiate the handling of events generated by the original aggregate and any furhter associated 
        /// commands and events generated by all configured handlers.  Brokering occurs within the domain engine transaction.
        /// </summary>
        /// <param name="eventBroker">The custom event broker to use, any events returned by the event broker are added to the events returned when processing a commmand.</param>
        /// <returns>Domain inteface for processing commands.</returns>
        public DomainEngine WithEventBroker(IEventBroker eventBroker)
        {
            this.eventBroker = eventBroker;
            return this;
        }

        /// <summary>
        /// Informs the domain engine to use the provided dispatcher to pass commands onto to external handlers whislt withing he domain engine transaction.
        /// </summary>
        /// <param name="eventDispatcher">Tne custom event dispatcher to use.  Dispatching is one way and any endpoints called do not effect the results returned when
        /// processign a command.</param>
        /// <returns>Domain inteface for processing commands.</returns>
        public DomainEngine WithEventDispatcher(IEventDispatcher eventDispatcher)
        {
            this.eventDispatcher = eventDispatcher;
            return this;
        }

        /// <summary>
        /// Informs the domain engine to before returning the events generated by processign a command to first enqueue each event onto an external queue, this enque happens within
        /// the domain engine transaction.
        /// </summary>
        /// <param name="eventQueue">The event queue target. </param>
        /// <returns>Domain inteface for processing commands.</returns>
        public DomainEngine WithEventQueue(IEventQueueWriter eventQueue)
        {
            this.eventQueue = eventQueue;
            return this;
        }

        /// <summary>
        /// Process a command through a command handler and aggregate root.  Additional processing through event handlers and aggregates enrolled by process managers may
        /// occur depending on how the domain engine is configured.
        /// </summary>
        /// <param name="command">The command to process.</param>
        /// <returns>Any events gernerated as a result of processing the command.</returns>
        public IEnumerable<IEvent> Process(ICommand command)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using (var transactionScope = DomainTransaction.DefaultTransactionScope())
            {
                try
                {
                    var resultingEvents = this.ProcessCommand(command);

                    this.DispatchEvents(resultingEvents);

                    this.EnqueueEvents(resultingEvents);

                    if (!this.domainOptions.Contains(DomainOption.CacheRuntimeModel))
                    {
                        this.runtimeModel.Clear();
                    }

                    transactionScope.Complete();

                    return resultingEvents;
                }
                catch (Exception)
                {
                    this.runtimeModel.Clear();
                    throw;
                }
            }
        }

        private IEnumerable<IEvent> ProcessCommand(ICommand command)
        {
            var resultingEvents = new List<IEvent>();

            resultingEvents.AddRange(this.commandHandler.HandleCommand(command, command.AggregateId, ((IBoundedContextModel)this.boundedContextModel).GetAggregateType(command.CommandBody.GetType())));

            resultingEvents.AddRange(this.BrokerEvents(resultingEvents));

            return resultingEvents;
        }

        private IEnumerable<IEvent> BrokerEvents(IEnumerable<IEvent> events)
        {
            var results = new List<IEvent>();

            if (this.eventBroker != null)
            {
                events.ToList().ForEach(e => results.AddRange(this.eventBroker.BrokerEvent(e.AsFullyTypedEvent(e.EventBody))));
            }

            return results;
        }

        private void DispatchEvents(IEnumerable<IEvent> events)
        {
            if (this.eventDispatcher != null)
            {
                this.eventDispatcher.DispatchEvents(events);
            }
        }

        private void EnqueueEvents(IEnumerable<IEvent> resultingEvents)
        {
            if (eventQueue != null)
            {
                resultingEvents.ToList().ForEach(e => this.eventQueue.Enqueue(e));
            }
        }
    }
}
